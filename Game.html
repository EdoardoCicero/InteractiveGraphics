<!DOCTYPE html>

<html>

<head>
    <title>Game</title>
    <script type="text/javascript" src="./libs/three.js"></script>
    <script type="text/javascript" src="./libs/ammo.js"></script>
    <script type="text/javascript" src="./libs/stats.js"></script>
	<script type="text/javascript" src="./libs/KeyboardState.js"></script>
    <script type="text/javascript" src="./libs/dat.gui.js"></script>
    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>

<div id="Stats-output">
</div>
<!-- Div which will hold the Output -->
<div id="WebGL-output">
</div>

	
<!-- Javascript code that runs our Three.js examples -->
<script type="text/javascript">
	
	// clock
	var clock = new THREE.Clock();
	
	// create a scene, that will hold all our elements such as objects, cameras and lights.
	var scene = new THREE.Scene();

	// create a camera, which defines where we're looking at.
	var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

	// create a render and set the size
	var webGLRenderer = new THREE.WebGLRenderer();
	
	var worldTime = 0;
	
	webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));
	webGLRenderer.setSize(window.innerWidth, window.innerHeight);
	webGLRenderer.shadowMapEnabled = true;

	

	// position and point the camera to the center of the scene
	camera.position.x = 0;
	camera.position.y = 12;
	camera.position.z = 20;
	camera.lookAt(new THREE.Vector3(0, 5, 0));
	
	// add the output of the renderer to the html element
	document.getElementById("WebGL-output").appendChild(webGLRenderer.domElement);
	
	function createMesh(geom) {

		// assign two materials
		var meshMaterial = new THREE.MeshNormalMaterial();
		meshMaterial.side = THREE.DoubleSide;
		var wireFrameMat = new THREE.MeshBasicMaterial();
		wireFrameMat.wireframe = true;

		// create a multimaterial
		var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMat]);

		return mesh;
	}
</script>
	
	
	
------------------------------------------------------------------------------------------------------------------
	
	
	
<script type="text/javascript">
//SCRIPT PER IL ROBOT


	// call the render function
	var step = 0;
	var time = 0;
	var time1 = 0;

	// once everything is loaded, we run our Three.js stuff.
	var keyboard	= new THREEx.KeyboardState();

	var velocity=0;
	var velocityDir=0;
	var maxvelocity= 6.0;
	var robotScale=1.7;
	
	// create meshes
	var robot = new THREE.Group();
	robot.position.set(0,robotScale,0);
	
	var rotator = new THREE.Object3D();
	
	var sphere = createMesh(new THREE.SphereGeometry(robotScale, 8, 8));
	
	var head = createMesh(new THREE.BoxGeometry(0.8*robotScale,0.5*robotScale,0.5*robotScale));
	head.position.set(0,1.3*robotScale,0);
	
	
	var upLegs = [];
	var downLegs = [];
	var upLegsLength =1.3;
	var downLegsLength =1;
	var knees = [];
	var feet = [];
	var upLegsInitialRotation = [[]];
	
	var rotationAngles = [0,0,-Math.PI/8,Math.PI];
	
	var sphereId = 0;
	var headId = 1;
	var upLegsId = 2;
	var kneesId = 3;	
	var sign = 1;
	var sign1 = 1;
	var sign2 = 1;
	var sign3 = 0;
	var sign4 = 0;
	
	
	for(var i =0; i<8; i++)
	{
		upLegs[i]= createMesh(new THREE.CylinderGeometry(0.2*robotScale,0.1*robotScale,upLegsLength*robotScale,3));
		knees[i]= new THREE.Object3D();
		downLegs[i]= createMesh(new THREE.CylinderGeometry(0.07*robotScale,0.2*robotScale,downLegsLength*robotScale,3));
		feet[i]= new THREE.Object3D();
	}
		
	function initializeLegs()
	{
		for(var i=0; i<8; i++)
		{
			upLegs[i].position.set(0,-0.45*robotScale,0);
			upLegs[i].rotation.set(0,0,Math.PI/2);
			
			if(i<4)
				upLegs[i].rotateX((Math.PI/5)*(i+1));
			
			else
				upLegs[i].rotateX((-Math.PI/5)*(i-3));
			
			upLegs[i].rotateZ(rotationAngles[upLegsId] = -Math.PI/8);
			
			knees[i].position.set(0,(upLegsLength/2)*robotScale,0);
			knees[i].rotation.set(0,0,rotationAngles[kneesId] = Math.PI);

			downLegs[i].position.set(0,(downLegsLength/2)*robotScale,0);

			feet[i].position.set(0,(downLegsLength/2)*robotScale,0);
			feet[i].rotation.set(0,0,0);
			
			upLegsInitialRotation[i] = upLegs[i].rotation.clone();
		}
	}
	
	initializeLegs();
	
	
	var counter=0;
	var counter1=0;
	var counter2=0;
	var headIsRotating=false;
	var robotIsMoving;
	var transformation= 0;
	var dampingX, dampingY, dampingZ;
	var step=false;
	var step1=false;
	var step2=false;
	var transitions=0;
	var spyderMode=false;
	var legId;
	var robotHeight= robotScale+(0.2*robotScale);

	
	//var robot = new THREE.Group();
	//robot.add( neck );
	robot.add( sphere );
	robot.add( head );
	robot.add( rotator );
	
	var legs = new THREE.Group();
	for(var i =0; i<8; i++)
	{
		legs.add(upLegs[i]);
		legs.add(downLegs[i]);
	}
	
	//add the robot to the scene
	scene.add(robot);
	
	robot.add(sphere, rotator);
	rotator.add(head);

	//render();
	function velocityCalculation()
	{
		if(keyboard.pressed("A") & keyboard.pressed("D"))
		{
			if (Math.abs(velocity)>0.1)
			{
				velocity = velocity/1.1;
			}
			else
				velocity = 0;
			velocityDir = 0;
		}
		else if(keyboard.pressed("D"))
		{
			if (velocity<maxvelocity)
			{
				velocity += 0.25;
				velocityDir =1;
			}
		}
		else if(keyboard.pressed("A"))
		{
			if (velocity>-maxvelocity)
			{
				velocity -= 0.25;
				velocityDir =-1;
			}
		}
		else
		{
			if (Math.abs(velocity)>0.1)
			{
				velocity = velocity/1.1;
			}
			else
				velocity = 0;
			velocityDir = 0;
		}
		
	}
	
	function robotSelfAnimation()
	{
		if ( !headIsRotating && Math.random() >= 0.99)
			{
				headIsRotating=true;
				
				if(Math.random() >= 0.5)
					sign = -sign;
				counter=0;
			}

		if (headIsRotating && Math.abs(counter)<2*Math.PI)
			{
				counter += sign * 0.4;
				head.rotation.y = counter;
			}
		else
			{
				headIsRotating = false;
			}
		
		
		rotator.rotation.z= dampingZ = sign1*0.5*Math.sin(2*time);
		rotator.rotation.x= dampingX = sign2*0.5*Math.sin(3*time);
		
		if(spyderMode && !robotIsMoving)
		{
			robot.translateY(-0.01*(robotScale/3)*(Math.sin(3*time1)));
			for(var i=0; i<8; i++)
			{
				upLegs[i].rotateZ(-0.005*(Math.sin(3*time1)));
				knees[i].rotateZ(0.005*(Math.sin(3*time1)));
			}
			time1+=0.015;
		}
		

	}
	
	function robotRoll() 
	{	
		sphere.rotation.z = rotationAngles[sphereId] -= 0.05*velocity;
		robot.translateX(0.05*velocity*robotScale); 

		/*var axisY = new THREE.Vector3(robot.position.x,robot.position.y+(0.15*(Math.abs(velocity))),0);
		rotator.translateOnAxis(rotator.worldToLocal(axisY),0.3); */
		
		rotator.position.y = 0.1*(Math.abs(velocity))*robotScale;
		
		head.rotation.z = 0.3*velocity;
		
		
		if (Math.abs(velocity)==0)	
			robotSelfAnimation();

		else
		{
			rotator.rotation.z = -0.2*velocity+dampingZ;
			rotator.rotation.x = dampingX = dampingX/1.2;
			dampingZ=dampingZ/1.12;
			time=0;
			if(Math.random() >= 0.5)
			{
				sign1= -sign1;
			}if(Math.random() >= 0.5)
			{
				sign2= -sign2;
			}
		}
		
		if (headIsRotating && velocity!=0)
		{
			if(counter<2*Math.PI)
			{
				if (headIsRotating && counter<2*Math.PI)
			{
				counter += 0.4;
				head.rotation.y = counter;
			}
			else
			{
				headIsRotating = false;
				counter = 0;
			}
			}
		}
	}
		
	function headAtCenter()
	{
		rotator.rotation.z= rotator.rotation.z/1.1;
		rotator.rotation.x= rotator.rotation.x/1.1;
		head.rotation.y = head.rotation.y/1.1

	}
	
	function ballToLegsTransformation()
	{
		time1=0;
		scene.add(legs);
		robot.add(legs);
		robotSelfAnimation();

		for(var i =0; i<8; i++)
		{
			upLegs[i].add(knees[i]);
			knees[i].add(downLegs[i]);
			downLegs[i].add(feet[i]);
		}
		
		if (upLegs[0].position.y < -0.1*robotScale)
		{
			for(var i =0; i<8; i++)
				upLegs[i].translateY(0.1);
		}
		
		else if(rotationAngles[kneesId] > 0.5*Math.PI)
		{
			for(var i =0; i<8; i++)
				knees[i].rotation.z = rotationAngles[kneesId];
			
			rotationAngles[kneesId] -= 0.06;
		}
		
		else if(feet[0].getWorldPosition().y>0 && !step)
		{
				for(var i =0; i<8; i++)
				{
					upLegs[i].rotateZ(0.01);
				}
		}
		
		else if(robot.position.y<robotHeight)
		{
			step=true;
			if(feet[0].getWorldPosition().y<=0 || feet[1].getWorldPosition().y<=0)
				robot.translateY(0.02*(robotScale/3));
			else
			{
				for(var i=0; i<8; i++)
				{
					upLegs[i].rotateZ(0.01);
					knees[i].rotateZ(-0.01);
				}
			}
		}
		
		else
		{
			step=false;
			transformation=2;
			//time=0;
			spyderMode=true;
		}
		

		
	}
	
	function legsAnimation()
	{
		function legStep()
		{
			
			
			if (sign3==0)
			{
				if(velocityDir>0)
					sign3=1;
				else if (velocityDir<0)
					sign3=-1;
				
			}
			else
			{
				var c=(sign3+1)/2;
				robotIsMoving=true;
				if (counter1<4)
				{
					upLegs[0+c].rotateZ(-0.15);
					upLegs[0+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
					upLegs[2+c].rotateZ(-0.15);
					upLegs[2+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
					upLegs[4+c].rotateZ(-0.15);
					upLegs[4+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
					upLegs[6+c].rotateZ(-0.15);
					upLegs[6+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
					
					counter1++;
					
					if(step1)
					{
						upLegs[1-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
						upLegs[3-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
						upLegs[5-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
						upLegs[7-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
						
						robot.translateX(sign3*0.1*robotScale);
					}
				}
				else if(counter1<8)
				{
					upLegs[0+c].rotateZ(0.15);
					upLegs[0+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
					upLegs[2+c].rotateZ(0.15);
					upLegs[2+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
					upLegs[4+c].rotateZ(0.15);
					upLegs[4+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
					upLegs[6+c].rotateZ(0.15);
					upLegs[6+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);

					counter1++;
					
					if(step1)
					{
						upLegs[1-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
						upLegs[3-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
						upLegs[5-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
						upLegs[7-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
						
						robot.translateX(sign3*0.1*robotScale);
					}
					
					if(velocityDir==sign3)
						step2=true;
					if(velocityDir==0 || velocityDir!=sign3 || transformation==3)
						step2=false;
				}
				else if(counter1<12)
				{
					upLegs[0+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
					upLegs[2+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
					upLegs[4+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
					upLegs[6+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
					
					upLegs[1-c].rotateZ(-0.15);
					upLegs[3-c].rotateZ(-0.15);
					upLegs[5-c].rotateZ(-0.15);
					upLegs[7-c].rotateZ(-0.15);

					
					if(step2)
					{
						upLegs[1-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
						upLegs[3-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
						upLegs[5-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
						upLegs[7-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
					}

					robot.translateX(sign3*0.1*robotScale);
					counter1++;
				}
				else if(counter1<16)
				{
					upLegs[0+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
					upLegs[2+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
					upLegs[4+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
					upLegs[6+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
					
					upLegs[1-c].rotateZ(0.15);
					upLegs[3-c].rotateZ(0.15);
					upLegs[5-c].rotateZ(0.15);
					upLegs[7-c].rotateZ(0.15);

					
					if(step2)
					{
						upLegs[1-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
						upLegs[3-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
						upLegs[5-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
						upLegs[7-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
					}
					
					
					robot.translateX(sign3*0.1*robotScale);
					counter1++;
					
					if(velocityDir==sign3)
						step1=true;
					if(velocityDir==0 || velocityDir!=sign3 || transformation==3)
						step1=false;
				}
				else if(!step2)
				{
					transitions=0;
					counter1=0;
					sign3=0;
					robotIsMoving=false;
					step1=false;
					step2=false;
				}
				else if(counter1<20 && !step1)
				{
					
					upLegs[1-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
					upLegs[3-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
					upLegs[5-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
					upLegs[7-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
					
					upLegs[c].rotateZ(-0.15);
					upLegs[2+c].rotateZ(-0.15);
					upLegs[4+c].rotateZ(-0.15);
					upLegs[6+c].rotateZ(-0.15);
					
					robot.translateX(sign3*0.1*robotScale);
					counter1++;
					
				}
				else if(counter1<24 && !step1)
				{
					upLegs[1-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
					upLegs[3-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
					upLegs[5-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
					upLegs[7-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
					
					upLegs[0+c].rotateZ(0.15);
					upLegs[2+c].rotateZ(0.15);
					upLegs[4+c].rotateZ(0.15);
					upLegs[6+c].rotateZ(0.15);
					
					robot.translateX(sign3*0.1*robotScale);
					counter1++;
				}
				else if(!step1)
				{
					transitions=0;
					counter1=0;
					sign3=0;
					robotIsMoving=false;
					step1=false;
					step2=false;
				}
				else
				{
					counter1=0;
					robot.translateX(sign3*0.1*robotScale);
				}
			}
		}
		
		
		switch(transitions)
		{
			case 0:
				if (velocityDir!=0)
				{
					transitions=1;
				}
				robotSelfAnimation();
				
				if(keyboard.pressed("space"))
					transitions=2;
				
				break;
			case 1:
				legStep();
				robotSelfAnimation();
				
				break;
			case 2:
				climb();
				break;
		}
	}
	
	function legsToBallTransformation()
	{
		spyderMode=false;
		robotSelfAnimation();
		if(robot.position.y>robotScale)
		{
			if(feet[0].getWorldPosition().y>0)
				robot.translateY(-0.02*(robotScale/3));
			else
				for(var i=0; i<8; i++)
				{
					upLegs[i].rotateZ(-0.01);
					knees[i].rotateZ(0.01);
				}
		}
		else if (upLegs[0].rotation.z > upLegsInitialRotation[0].z)
		{
			for(var i =0; i<8; i++)
				upLegs[i].rotateZ(-0.01);
		}
		else if(rotationAngles[kneesId] < Math.PI)
		{
			for(var i =0; i<8; i++)
				knees[i].rotation.z = rotationAngles[kneesId];
			rotationAngles[kneesId] += 0.06;

		}
		else if(upLegs[0].position.y > -0.33*robotScale)
		{
			for(var i =0; i<8; i++)
				upLegs[i].translateY(-0.1);
		}
		else
		{
			transformation=0;
			scene.remove(legs);
			robot.remove(legs);
			initializeLegs()
		}
		
		
	}
	
	function robotAnimation() {

		time += 0.015;
		
		camera.position.x = robot.position.x+velocity/2;

		if(keyboard.pressed("1"))
		{
			if(transformation==0)
				transformation = 1;
			else if (transformation==2)
				transformation = 3;
		}
		
		switch (transformation)
		{
			case 0:
				velocityCalculation();
				robotRoll();
				break;
				
			case 1:
				if (Math.abs(velocity)>0.3)
				{
					velocity=velocity/1.1;
					robotRoll();
				}
				else
				{
					ballToLegsTransformation();
					velocity=velocity/1.1;
				}
				break;
				
			case 2:
				velocityCalculation();
				legsAnimation();
				break;
				
			case 3:
				if (robotIsMoving)
				{
					velocityCalculation();
					robotSelfAnimation();
					legsAnimation();
				}
				else
				{
					transitions=0;
					legsToBallTransformation();
					velocity=velocity/1.1;
				}
				break;
				
		}
		// render using requestAnimationFrame
		requestAnimationFrame(robotAnimation);
		webGLRenderer.render(scene, camera);
	}
	
	robotAnimation();
</script>
	
	
	
	
	
	
	
<script type="text/javascript">
//SCRIPT PER LA MAPPA

	var doorsArray = [];
	var roomHasFrontDoor = [];
	var roomHasBackDoor = [];
	var boxLength =1.7;
	var boxDepth = 1.1;
	
	//-------------------------------------------------------//
	//-----------------------OBJECTS-------------------------//
	//-------------------------------------------------------//

		
	//CREATE A WALL
	function createWall(wallWidth, roomHeight)
	{
		var wall=createMesh(new THREE.PlaneBufferGeometry(wallWidth,roomHeight,1,1))
		return wall;
	}
	
	//CREATE A WINDOW
	function createWindow(starshipWindowWidth, starshipWindowHeight)
	{
		var starshipWindow = new THREE.Group();
		
		var bottomS = createMesh(new THREE.BoxGeometry(starshipWindowWidth,2,2));
		bottomS.position.set(0,-starshipWindowHeight/2+1,0);
		var topS = createMesh(new THREE.BoxGeometry(starshipWindowWidth,2,2));
		topS.position.set(0,starshipWindowHeight/2-1,0);
		var leftS = createMesh(new THREE.BoxGeometry(2,starshipWindowHeight,2));
		leftS.position.set(-starshipWindowWidth/2,0,0);
		var rightS = createMesh(new THREE.BoxGeometry(2,starshipWindowHeight,2));
		rightS.position.set(starshipWindowWidth/2,0,0)
		
		starshipWindow.add(bottomS, topS, leftS, rightS);

		return starshipWindow;
	}
	
	//CREATE A DOOR
	function createDoor(doorHeight, doorWidth)
	{
		var door = createMesh(new THREE.BoxGeometry(1.2,doorHeight,doorWidth));
		return door;
	}
	
	
	//CREATE A WALL FOR DOOR
	function createWallForDoor(depth,height)
	{
		var doorWidth=8;
		var doorHeight=10;
		
		var wall1 = createMesh(new THREE.BoxGeometry(2,height,(depth-doorWidth)/2));
		wall1.position.set(0,height/2,-(doorWidth/2)-((depth-doorWidth)/4));
		var wall2 = createMesh(new THREE.BoxGeometry(2,height,(depth/2)-(doorWidth/2)));
		wall2.position.set(0,height/2,+(doorWidth/2)+((depth-doorWidth)/4));
		var wall3 = createMesh(new THREE.BoxGeometry(2,height-doorHeight,doorWidth));
		wall3.position.set(0,height-((height-doorHeight)/2),0);
		
		
		
		var wallForDoor = new THREE.Group();
		wallForDoor.add(wall1,wall2,wall3);
		
		return wallForDoor;
	}

	//CREATE A SURVEILLANCE CAMERA
	function createSurveillanceCamera()
	{
		var surveillanceCamera = new THREE.Group();
		
		var box = createMesh(new THREE.BoxGeometry(boxLength,boxDepth,boxDepth));
		
		var eye = createMesh(new THREE.CylinderGeometry(boxDepth*0.4,boxDepth*0.4,boxLength/3,8));
		eye.rotation.z=Math.PI/2;
		eye.position.x=-boxLength/2;
		
		surveillanceCamera.add(box,eye);
		surveillanceCamera.rotation.z=Math.PI/6;
		
		return surveillanceCamera;
	}
	function createSubstainForSurvaillanceCamera()
	{
		var substainForSurveillanceCamera = new THREE.Group();
		
		var stick1 = createMesh(new THREE.CylinderGeometry(boxDepth*0.2,boxDepth*0.2,boxLength*0.8,3));
		
		var stick2 = createMesh(new THREE.CylinderGeometry(boxDepth*0.2,boxDepth*0.2,boxLength*1.5,3));
		stick2.position.set(boxLength/2,+boxLength/10,0);
		stick2.rotation.z=-Math.PI/4;
		
		substainForSurveillanceCamera.add(stick1,stick2);
		substainForSurveillanceCamera.position.y=-boxLength/2;

		
		return substainForSurveillanceCamera;
	}

	
	//-----------------------------------------------------//
	//-----------------------ROOMS-------------------------//
	//-----------------------------------------------------//

	
	//CREATE A STARSHIP'S ROOM WITH WINDOW (COLUMN OR DOOR)
	function createStandardRoom (window,column, num)
	{
		var standardRoom = new THREE.Group();
		
		//room size
		var roomWidth = 60;
		var roomDepth = 20;
		var roomHeight = 15;
		
		var floor = createMesh(new THREE.PlaneBufferGeometry(roomWidth,roomDepth,1,1));
		floor.rotation.set(-Math.PI/2,0,0);
		standardRoom.add(floor);

		if(window)
		{
			//a starship window and walls
			var pieceOfWallWidth = roomWidth/8;
			var starshipWindowWidth = roomWidth-(2*pieceOfWallWidth);
			var starshipWindowHeight = roomHeight;

			var starshipWindow = createWindow(starshipWindowWidth, starshipWindowHeight);
			starshipWindow.position.set(0,starshipWindowHeight/2,-roomDepth/2);
			standardRoom.add(starshipWindow);

			var wallR = createWall(pieceOfWallWidth,roomHeight);
			wallR.position.set((starshipWindowWidth/2)+(pieceOfWallWidth/2),roomHeight/2,-roomDepth/2);
			var wallL = createWall(pieceOfWallWidth,roomHeight);
			wallL.position.set(-(starshipWindowWidth/2)-(pieceOfWallWidth/2),roomHeight/2,-roomDepth/2);
			standardRoom.add(wallR, wallL);
		}
		else
		{
			var wall = createWall(roomWidth,roomHeight);
			wall.position.set(0,roomHeight/2,-roomDepth/2);
			standardRoom.add(wall);
		}

		//ceiling
		var ceiling = createMesh(new THREE.PlaneBufferGeometry(roomWidth,roomDepth,1,1));;
		ceiling.rotation.set(Math.PI/2,0,0);
		//floor.rotation.set(Math.PI,0,0);
		ceiling.position.y=roomHeight;
		standardRoom.add(ceiling);

		//column
		if(column)
		{
			var column = createMesh(new THREE.BoxGeometry(5,roomHeight,4));
			column.position.set(roomWidth/2,roomHeight/2,-roomDepth/2+2);
			standardRoom.add(column);
		}
		else
		{
			var wallForDoor = createWallForDoor(roomDepth,roomHeight);
			wallForDoor.position.x=roomWidth/2;
			standardRoom.add(wallForDoor);
			
			var door = createDoor(10, 8);
			door.position.set(30+60*num,5,0);
			
			doorsArray[num]=door;
			roomHasBackDoor[num+1]=true;
			
			scene.add(doorsArray[doorsArray.length-1]);
			
		}
		
		standardRoom.position.x=60*(num);
		return standardRoom;
	}
	
	//CREATE A CIRCULAR ROOM
	function createCircleRoom(column,num)
	{
	
		var circleRoom = new THREE.Group();
	
		var numOfSegments = 32;
		var radius = 32;
		var roomHeight = 15;
		
		//floor circle
		var floor = createMesh(new THREE.CircleGeometry(radius,numOfSegments));
		floor.rotation.set(-Math.PI/2,0,0);
		circleRoom.add(floor);
		
		//circular wall
		var wall = new THREE.Group();
		var wallPieces = [];
		for(i=3; i<numOfSegments-3; i++)
		{
			wallPieces[i]=createWall((radius*Math.PI)/numOfSegments,roomHeight);
			wallPieces[i].rotation.y=Math.PI/2-(i*Math.PI/numOfSegments);
			wallPieces[i].translateZ(-radius);
			wallPieces[i].position.y=roomHeight/2;
			wall.add(wallPieces[i]);
		}
		
		//ceiling
		var ceiling = createMesh(new THREE.CircleGeometry(radius,numOfSegments));
		ceiling.rotation.set(Math.PI/2,0,0);
		ceiling.position.y=roomHeight;
		circleRoom.add(ceiling);
		
		//wall with door
		/*var wallForDoor = createWallForDoor(39,roomHeight);
		wallForDoor.position.x=radius-2;*/
		//circleRoom.add(wallForDoor);
		
		circleRoom.add(wall);
		
		//column
		if(column)
		{
			var column = createMesh(new THREE.BoxGeometry(5,roomHeight,4));
			column.position.set(radius-2,roomHeight/2,-39/2+2);
			circleRoom.add(column);
		}
		else
		{
			var wallForDoor = createWallForDoor(39,roomHeight);
			wallForDoor.position.x=radius-2;
			circleRoom.add(wallForDoor);
			
			var door = createDoor(10, 8);
			door.position.set(30+60*num,5,0);
			
			doorsArray[num]=door;
			roomHasBackDoor[num+1]=true;
			
			scene.add(doorsArray[doorsArray.length-1]);
			
		}
		
		circleRoom.position.x= num*60;
		return circleRoom;
		
	}
	

	var rooms = [];
	rooms[0] = createStandardRoom(true,false,0);
	rooms[1] = createStandardRoom(false,true,1);
	rooms[2] = createStandardRoom(true,false,2);
	rooms[3] = createCircleRoom(false,3);
	
	for(i=0; i<rooms.length; i++)
		scene.add(rooms[i]);
	
	var surveillanceCamera = createSurveillanceCamera();	
	var substainForSurvaillanceCamera = createSubstainForSurvaillanceCamera();
	var securityCamera = new THREE.Group();
	securityCamera.position.set( 30 - 2.2, 13, 0 );

	securityCamera.add(surveillanceCamera, substainForSurvaillanceCamera);
	
	scene.add(securityCamera);
	
	
	//---------------------------------------------------------//
	//-----------------------ANIMATION-------------------------//
	//---------------------------------------------------------//
	
	
	function doorsAnimation()
	{
		var currentRoom = Math.floor((robot.position.x+30)/60);
		
		
		if (roomHasBackDoor[currentRoom+1])
		{
			if (robot.position.x>17+(60*currentRoom))
			{
				if(doorsArray[currentRoom].position.z>-7)
				{
					doorsArray[currentRoom].translateZ(-0.5);
				}
			}
			else
				if(doorsArray[currentRoom].position.z<=0)
				{
					doorsArray[currentRoom].translateZ(0.5);
				}
		}
		if (roomHasBackDoor[currentRoom])
			if (robot.position.x<(60*(currentRoom-1))+47)
			{
				if(doorsArray[currentRoom-1].position.z>-7)
				{
					doorsArray[currentRoom-1].translateZ(-0.5);
				}
			}
			else
				if(doorsArray[currentRoom-1].position.z<=0)
				{
					doorsArray[currentRoom-1].translateZ(0.5);
				}
	}
	
	function surveillanceCameraAnimation()
	{
		surveillanceCamera.rotation.y=(Math.PI/6)*Math.sin(0.7*worldTime);
	}
	
	function mapAnimation()
	{
		worldTime += clock.getDelta();
		doorsAnimation();
		surveillanceCameraAnimation()
		
		requestAnimationFrame(mapAnimation);
	}
	
	mapAnimation();
	
</script>
	
	

	
<script type="text/javascript">
//SCRIPT PER IL RENDERING
	webGLRenderer.render(scene, camera);
</script>

	
	
	
</body>
</html>